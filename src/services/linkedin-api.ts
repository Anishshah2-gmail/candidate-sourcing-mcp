/**
 * LinkedIn Talent Solutions API Integration
 *
 * This service handles all communication with LinkedIn's Recruiter/Talent APIs.
 * Supports OAuth 2.0 authentication and the People Search API.
 */

import {
  Candidate,
  CandidateDetailed,
  SearchFilters,
  SearchResult,
  SeniorityLevel,
  IDataProvider,
  ProviderStatus,
} from "../types/index.js";

// LinkedIn API configuration
interface LinkedInConfig {
  clientId: string;
  clientSecret: string;
  accessToken?: string;
  refreshToken?: string;
  tokenExpiry?: number;
}

// LinkedIn API response types (based on Talent Solutions API)
interface LinkedInSearchResponse {
  elements: LinkedInProfile[];
  paging: {
    count: number;
    start: number;
    total?: number;
    links?: Array<{ rel: string; href: string }>;
  };
}

interface LinkedInProfile {
  id: string;
  firstName?: { localized?: Record<string, string> };
  lastName?: { localized?: Record<string, string> };
  headline?: { localized?: Record<string, string> };
  profilePicture?: { displayImage: string };
  vanityName?: string;
  industryName?: { localized?: Record<string, string> };
  geoLocation?: {
    geoUrn?: string;
    autoGenerated?: { name?: string };
  };
  positions?: {
    elements?: LinkedInPosition[];
  };
  skills?: {
    elements?: Array<{ name?: string }>;
  };
  education?: {
    elements?: LinkedInEducation[];
  };
}

interface LinkedInPosition {
  title?: { localized?: Record<string, string> };
  companyName?: { localized?: Record<string, string> };
  locationName?: string;
  timePeriod?: {
    startDate?: { year: number; month?: number };
    endDate?: { year: number; month?: number };
  };
  description?: { localized?: Record<string, string> };
  isCurrent?: boolean;
}

interface LinkedInEducation {
  schoolName?: string;
  degreeName?: string;
  fieldOfStudy?: string;
  timePeriod?: {
    startDate?: { year: number; month?: number };
    endDate?: { year: number; month?: number };
  };
}

// Seniority mapping for LinkedIn API
const SENIORITY_MAP: Record<SeniorityLevel, string[]> = {
  entry: ["1"],
  junior: ["2"],
  mid: ["3", "4"],
  senior: ["5", "6"],
  lead: ["7"],
  manager: ["8"],
  director: ["9"],
  vp: ["10"],
  "c-level": ["11"],
  owner: ["12"],
};

export class LinkedInApiService implements IDataProvider {
  readonly providerName = "linkedin" as const;
  private config: LinkedInConfig;
  private baseUrl = "https://api.linkedin.com/v2";
  private talentBaseUrl = "https://api.linkedin.com/v2"; // Talent Solutions uses same base
  private rateLimitRemaining?: number;
  private rateLimitReset?: string;

  constructor(config: LinkedInConfig) {
    this.config = config;
  }

  isConfigured(): boolean {
    return !!(this.config.clientId && this.config.clientSecret && this.config.accessToken);
  }

  getStatus(): ProviderStatus {
    return {
      provider: "linkedin",
      configured: this.isConfigured(),
      rateLimitRemaining: this.rateLimitRemaining,
      rateLimitReset: this.rateLimitReset,
      message: this.isConfigured()
        ? "LinkedIn Talent API configured and ready"
        : "Missing LinkedIn API credentials (LINKEDIN_CLIENT_ID, LINKEDIN_CLIENT_SECRET, LINKEDIN_ACCESS_TOKEN)",
    };
  }

  /**
   * Refresh OAuth token if expired
   */
  private async ensureValidToken(): Promise<string> {
    if (!this.config.accessToken) {
      throw new Error(
        "No access token configured. Please provide LinkedIn API credentials."
      );
    }

    // Check if token is expired and refresh if needed
    if (
      this.config.tokenExpiry &&
      Date.now() > this.config.tokenExpiry &&
      this.config.refreshToken
    ) {
      await this.refreshAccessToken();
    }

    return this.config.accessToken;
  }

  /**
   * Refresh the access token using refresh token
   */
  private async refreshAccessToken(): Promise<void> {
    if (!this.config.refreshToken) {
      throw new Error("No refresh token available");
    }

    const response = await fetch("https://www.linkedin.com/oauth/v2/accessToken", {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
      },
      body: new URLSearchParams({
        grant_type: "refresh_token",
        refresh_token: this.config.refreshToken,
        client_id: this.config.clientId,
        client_secret: this.config.clientSecret,
      }),
    });

    if (!response.ok) {
      throw new Error(`Failed to refresh token: ${response.statusText}`);
    }

    const data = await response.json();
    this.config.accessToken = data.access_token;
    this.config.tokenExpiry = Date.now() + data.expires_in * 1000;
    if (data.refresh_token) {
      this.config.refreshToken = data.refresh_token;
    }
  }

  /**
   * Make an authenticated request to LinkedIn API
   */
  private async apiRequest<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const token = await this.ensureValidToken();

    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      ...options,
      headers: {
        Authorization: `Bearer ${token}`,
        "Content-Type": "application/json",
        "X-Restli-Protocol-Version": "2.0.0",
        ...options.headers,
      },
    });

    // Extract rate limit info from headers
    const rateLimitRemaining = response.headers.get("x-li-ratelimit-remaining");
    const rateLimitReset = response.headers.get("x-li-ratelimit-reset");

    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(
        `LinkedIn API error (${response.status}): ${errorBody}` +
          (rateLimitRemaining === "0"
            ? ` Rate limit exceeded. Resets at ${rateLimitReset}`
            : "")
      );
    }

    const data = await response.json();

    // Attach rate limit info to response if needed
    if (rateLimitRemaining) {
      (data as Record<string, unknown>)._rateLimitRemaining = parseInt(rateLimitRemaining);
      (data as Record<string, unknown>)._rateLimitReset = rateLimitReset;
    }

    return data as T;
  }

  /**
   * Build search query parameters for LinkedIn Recruiter Search API
   */
  private buildSearchParams(filters: SearchFilters): URLSearchParams {
    const params = new URLSearchParams();

    // Keywords from titles and must-have keywords
    const keywords: string[] = [];
    if (filters.titles?.length) {
      keywords.push(...filters.titles);
    }
    if (filters.mustHaveKeywords?.length) {
      keywords.push(...filters.mustHaveKeywords);
    }
    if (keywords.length) {
      params.set("keywords", keywords.join(" OR "));
    }

    // Location filters
    if (filters.locations?.length) {
      params.set("geoLocations", filters.locations.join(","));
    }

    // Skills
    if (filters.skills?.length) {
      params.set("skills", filters.skills.join(","));
    }

    // Experience years - converted to seniority levels if not directly supported
    // LinkedIn API typically uses seniority levels rather than years directly

    // Seniority levels
    if (filters.seniorityLevels?.length) {
      const seniorityIds = filters.seniorityLevels.flatMap(
        (level) => SENIORITY_MAP[level] || []
      );
      if (seniorityIds.length) {
        params.set("seniorities", seniorityIds.join(","));
      }
    }

    // Companies to include
    if (filters.includeCompanies?.length) {
      params.set("currentCompanies", filters.includeCompanies.join(","));
    }

    // Industries
    if (filters.industries?.length) {
      params.set("industries", filters.industries.join(","));
    }

    // Pagination
    params.set("count", String(filters.pageSize || 20));
    if (filters.cursor) {
      params.set("start", filters.cursor);
    }

    return params;
  }

  /**
   * Extract localized string from LinkedIn's localized field format
   */
  private getLocalizedString(
    field?: { localized?: Record<string, string> }
  ): string | undefined {
    if (!field?.localized) return undefined;
    // Return first available locale, preferring en_US
    return field.localized["en_US"] || Object.values(field.localized)[0];
  }

  /**
   * Calculate years of experience from positions
   */
  private calculateExperienceYears(positions?: LinkedInPosition[]): number | undefined {
    if (!positions?.length) return undefined;

    let totalMonths = 0;
    const now = new Date();

    for (const pos of positions) {
      if (!pos.timePeriod?.startDate) continue;

      const startYear = pos.timePeriod.startDate.year;
      const startMonth = pos.timePeriod.startDate.month || 1;

      let endYear: number;
      let endMonth: number;

      if (pos.timePeriod.endDate) {
        endYear = pos.timePeriod.endDate.year;
        endMonth = pos.timePeriod.endDate.month || 12;
      } else {
        endYear = now.getFullYear();
        endMonth = now.getMonth() + 1;
      }

      const months =
        (endYear - startYear) * 12 + (endMonth - startMonth);
      totalMonths += Math.max(0, months);
    }

    return Math.round(totalMonths / 12);
  }

  /**
   * Determine seniority level from title
   */
  private inferSeniorityFromTitle(title?: string): SeniorityLevel | undefined {
    if (!title) return undefined;

    const titleLower = title.toLowerCase();

    if (/(ceo|cto|cfo|coo|chief|founder)/i.test(titleLower)) return "c-level";
    if (/\b(vp|vice president)\b/i.test(titleLower)) return "vp";
    if (/\bdirector\b/i.test(titleLower)) return "director";
    if (/\b(manager|head of)\b/i.test(titleLower)) return "manager";
    if (/\b(lead|principal|staff)\b/i.test(titleLower)) return "lead";
    if (/\bsenior\b/i.test(titleLower)) return "senior";
    if (/\b(junior|jr\.?|associate)\b/i.test(titleLower)) return "junior";
    if (/\b(intern|trainee|entry)\b/i.test(titleLower)) return "entry";

    return "mid";
  }

  /**
   * Transform LinkedIn profile to our Candidate format
   */
  private transformProfile(profile: LinkedInProfile): Candidate {
    const firstName = this.getLocalizedString(profile.firstName) || "";
    const lastName = this.getLocalizedString(profile.lastName) || "";
    const headline = this.getLocalizedString(profile.headline);

    const currentPosition = profile.positions?.elements?.find((p) => p.isCurrent);
    const currentTitle = currentPosition
      ? this.getLocalizedString(currentPosition.title)
      : undefined;
    const currentCompany = currentPosition
      ? this.getLocalizedString(currentPosition.companyName)
      : undefined;

    const skills = profile.skills?.elements
      ?.map((s) => s.name)
      .filter((s): s is string => !!s);

    return {
      source: "linkedin",
      sourceId: profile.id,
      fullName: `${firstName} ${lastName}`.trim(),
      headlineOrTitle: headline,
      currentTitle,
      currentCompany,
      location: profile.geoLocation?.autoGenerated?.name,
      experienceYears: this.calculateExperienceYears(profile.positions?.elements),
      skills,
      profileUrl: profile.vanityName
        ? `https://www.linkedin.com/in/${profile.vanityName}`
        : `https://www.linkedin.com/profile/view?id=${profile.id}`,
      seniorityLevel: this.inferSeniorityFromTitle(currentTitle || headline),
      industries: profile.industryName
        ? [this.getLocalizedString(profile.industryName)!]
        : undefined,
      summary: headline,
    };
  }

  /**
   * Transform LinkedIn profile to detailed candidate format
   */
  private transformProfileDetailed(profile: LinkedInProfile): CandidateDetailed {
    const base = this.transformProfile(profile);

    const experience = profile.positions?.elements?.map((pos) => ({
      title: this.getLocalizedString(pos.title) || "Unknown",
      company: this.getLocalizedString(pos.companyName) || "Unknown",
      location: pos.locationName,
      startDate: pos.timePeriod?.startDate
        ? `${pos.timePeriod.startDate.year}-${String(pos.timePeriod.startDate.month || 1).padStart(2, "0")}`
        : undefined,
      endDate: pos.timePeriod?.endDate
        ? `${pos.timePeriod.endDate.year}-${String(pos.timePeriod.endDate.month || 1).padStart(2, "0")}`
        : undefined,
      description: this.getLocalizedString(pos.description),
      isCurrent: pos.isCurrent,
    }));

    const education = profile.education?.elements?.map((edu) => ({
      school: edu.schoolName || "Unknown",
      degree: edu.degreeName,
      fieldOfStudy: edu.fieldOfStudy,
      startDate: edu.timePeriod?.startDate
        ? `${edu.timePeriod.startDate.year}`
        : undefined,
      endDate: edu.timePeriod?.endDate
        ? `${edu.timePeriod.endDate.year}`
        : undefined,
    }));

    return {
      ...base,
      experience,
      education,
    };
  }

  /**
   * Filter candidates by exclusion criteria (post-processing)
   */
  private applyExclusions(
    candidates: Candidate[],
    filters: SearchFilters
  ): Candidate[] {
    let result = candidates;

    // Exclude companies
    if (filters.excludeCompanies?.length) {
      const excludeSet = new Set(
        filters.excludeCompanies.map((c) => c.toLowerCase())
      );
      result = result.filter(
        (c) =>
          !c.currentCompany ||
          !excludeSet.has(c.currentCompany.toLowerCase())
      );
    }

    // Exclude keywords
    if (filters.excludeKeywords?.length) {
      result = result.filter((c) => {
        const searchText = [
          c.fullName,
          c.headlineOrTitle,
          c.currentTitle,
          c.summary,
        ]
          .filter(Boolean)
          .join(" ")
          .toLowerCase();

        return !filters.excludeKeywords!.some((kw) =>
          searchText.includes(kw.toLowerCase())
        );
      });
    }

    // Filter by experience years
    if (filters.minExperienceYears !== undefined) {
      result = result.filter(
        (c) =>
          c.experienceYears === undefined ||
          c.experienceYears >= filters.minExperienceYears!
      );
    }
    if (filters.maxExperienceYears !== undefined) {
      result = result.filter(
        (c) =>
          c.experienceYears === undefined ||
          c.experienceYears <= filters.maxExperienceYears!
      );
    }

    return result;
  }

  /**
   * Search for candidates using LinkedIn Recruiter API
   */
  async searchCandidates(filters: SearchFilters): Promise<SearchResult> {
    const params = this.buildSearchParams(filters);

    // Note: The actual endpoint may vary based on your LinkedIn API access level
    // LinkedIn Recruiter uses different endpoints than basic API
    const endpoint = `/talentSolutions/people?${params.toString()}`;

    const response = await this.apiRequest<LinkedInSearchResponse>(endpoint);

    let candidates = response.elements.map((profile) =>
      this.transformProfile(profile)
    );

    // Apply post-processing filters
    candidates = this.applyExclusions(candidates, filters);

    const nextStart = response.paging.start + response.paging.count;
    const hasMore = response.paging.total
      ? nextStart < response.paging.total
      : response.elements.length === (filters.pageSize || 20);

    return {
      candidates,
      pagination: {
        nextCursor: hasMore ? String(nextStart) : undefined,
        hasMore,
        totalEstimated: response.paging.total,
      },
      meta: {
        rateLimitRemaining: (response as unknown as Record<string, unknown>)._rateLimitRemaining as number | undefined,
        rateLimitReset: (response as unknown as Record<string, unknown>)._rateLimitReset as string | undefined,
      },
    };
  }

  /**
   * Get detailed information for a specific candidate
   */
  async getCandidateDetails(sourceId: string): Promise<CandidateDetailed> {
    const endpoint = `/people/${sourceId}?projection=(id,firstName,lastName,headline,vanityName,industryName,geoLocation,positions,skills,education)`;

    const profile = await this.apiRequest<LinkedInProfile>(endpoint);

    return this.transformProfileDetailed(profile);
  }

  /**
   * Update access token (for external token refresh)
   */
  setAccessToken(token: string, expiresIn?: number): void {
    this.config.accessToken = token;
    if (expiresIn) {
      this.config.tokenExpiry = Date.now() + expiresIn * 1000;
    }
  }
}

// Singleton instance
let linkedInService: LinkedInApiService | null = null;

export function getLinkedInService(): LinkedInApiService {
  if (!linkedInService) {
    const clientId = process.env.LINKEDIN_CLIENT_ID;
    const clientSecret = process.env.LINKEDIN_CLIENT_SECRET;
    const accessToken = process.env.LINKEDIN_ACCESS_TOKEN;
    const refreshToken = process.env.LINKEDIN_REFRESH_TOKEN;

    if (!clientId || !clientSecret) {
      throw new Error(
        "LinkedIn API credentials not configured. Set LINKEDIN_CLIENT_ID and LINKEDIN_CLIENT_SECRET environment variables."
      );
    }

    linkedInService = new LinkedInApiService({
      clientId,
      clientSecret,
      accessToken,
      refreshToken,
    });
  }

  return linkedInService;
}

export function initLinkedInService(config: LinkedInConfig): LinkedInApiService {
  linkedInService = new LinkedInApiService(config);
  return linkedInService;
}
